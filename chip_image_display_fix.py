#!/usr/bin/env python3
"""
X-Seti - June07 2025 - CHIP IMAGE DISPLAY FIX
Connect your retro_chip_generator images with the canvas display system
"""

import os
import shutil
from datetime import datetime
from pathlib import Path

def backup_file(filepath):
    """Create a backup of a file before modifying"""
    if os.path.exists(filepath):
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = f"{filepath}.backup_{timestamp}"
        shutil.copy2(filepath, backup_path)
        print(f"âœ“ Backed up {filepath} to {backup_path}")
        return backup_path
    return None

def scan_existing_chip_images():
    """Scan for existing chip images generated by retro_chip_generator"""
    images_dir = Path("images/components")
    
    if not images_dir.exists():
        print(f"âŒ Images directory not found: {images_dir}")
        return []
    
    print(f"ğŸ” Scanning for chip images in: {images_dir}")
    
    # Find all PNG files
    image_files = list(images_dir.glob("*.png"))
    
    if not image_files:
        print("âŒ No PNG files found in images/components/")
        print("ğŸ’¡ You may need to run: python retro_chip_generator.py first")
        return []
    
    print(f"âœ… Found {len(image_files)} chip images:")
    for img in sorted(image_files)[:10]:  # Show first 10
        print(f"  ğŸ“„ {img.name}")
    
    if len(image_files) > 10:
        print(f"  ... and {len(image_files) - 10} more")
    
    return image_files

def create_enhanced_image_loader():
    """Create an enhanced image loader module"""
    
    loader_code = '''"""
X-Seti - June07 2025 - Enhanced Chip Image Loader
Connects retro_chip_generator images with canvas display
"""

import os
from pathlib import Path
from PyQt6.QtGui import QPixmap
from PyQt6.QtCore import Qt

class ChipImageLoader:
    """Enhanced loader for chip images"""
    
    def __init__(self):
        self.images_dir = Path("images/components")
        self.image_cache = {}
        self.load_image_mappings()
    
    def load_image_mappings(self):
        """Load mappings from component names to image files"""
        self.mappings = {
            # CPU mappings
            "6502": "cpu_6502_dip_40.png",
            "65c02": "cpu_6502_dip_40.png",
            "68000": "cpu_68000_dip_64.png",
            "mc68000": "cpu_68000_dip_64.png",
            "z80": "cpu_z80_dip_40.png",
            "zilog z80": "cpu_z80_dip_40.png",
            
            # Commodore 64 chips
            "vic-ii": "c64_vic2_dip_40.png",
            "vic2": "c64_vic2_dip_40.png",
            "6569": "c64_vic2_dip_40.png",
            "sid": "c64_sid_dip_28.png",
            "6581": "c64_sid_dip_28.png",
            "8580": "c64_sid_dip_28.png",
            "cia": "c64_cia_dip_40.png",
            "6526": "c64_cia_dip_40.png",
            
            # Amiga chips
            "agnus": "amiga_agnus_plcc_84.png",
            "8370": "amiga_agnus_plcc_84.png",
            "8371": "amiga_agnus_plcc_84.png",
            "denise": "amiga_denise_plcc_48.png",
            "8362": "amiga_denise_plcc_48.png",
            "paula": "amiga_paula_dip_48.png",
            "8364": "amiga_paula_dip_48.png",
            
            # ZX Spectrum
            "ula": "spectrum_ula_dip_40.png",
            "zx spectrum ula": "spectrum_ula_dip_40.png",
            
            # Nintendo NES
            "ppu": "nes_ppu_dip_40.png",
            "2c02": "nes_ppu_dip_40.png",
            "apu": "nes_apu_dip_40.png",
            "2a03": "nes_apu_dip_40.png",
            
            # BBC Micro
            "video ula": "bbc_video_ula_dip_40.png",
            "sn76489": "bbc_sn76489_dip_16.png",
            
            # Sega Genesis
            "genesis vdp": "genesis_vdp_qfp_64.png",
            "ym2612": "genesis_ym2612_dip_24.png",
            
            # MSX
            "tms9918a": "msx_tms9918a_dip_40.png",
            "ay-3-8910": "msx_ay3_8910_dip_28.png",
            "s1985": "msx_s1985_dip_64.png",
            
            # TI-99/4A
            "tms9900": "ti99_tms9900_dip_64.png",
            "tms9901": "ti99_tms9901_dip_40.png",
            
            # Dragon/CoCo
            "sam": "dragon_sam_dip_40.png",
            "mc6883": "dragon_sam_dip_40.png",
            
            # Oric
            "oric ula": "oric_ula_dip_40.png",
        }
    
    def find_chip_image(self, component_name: str) -> str:
        """Find the best matching chip image for a component"""
        if not component_name:
            return None
        
        # Clean the component name
        clean_name = component_name.lower().strip()
        clean_name = clean_name.replace("-", " ").replace("_", " ").replace("  ", " ")
        
        print(f"ğŸ” Looking for image for: '{component_name}' -> '{clean_name}'")
        
        # Try exact mapping first
        if clean_name in self.mappings:
            image_file = self.mappings[clean_name]
            image_path = self.images_dir / image_file
            if image_path.exists():
                print(f"âœ… Found exact match: {image_file}")
                return str(image_path)
        
        # Try partial matches
        for key, image_file in self.mappings.items():
            if key in clean_name or clean_name in key:
                image_path = self.images_dir / image_file
                if image_path.exists():
                    print(f"âœ… Found partial match: {key} -> {image_file}")
                    return str(image_path)
        
        # Try scanning all files for similar names
        if self.images_dir.exists():
            for image_file in self.images_dir.glob("*.png"):
                file_name = image_file.stem.lower()
                # Remove package type suffixes for matching
                file_base = file_name.replace("_dip_40", "").replace("_dip_28", "").replace("_plcc_84", "")
                file_base = file_base.replace("_qfp_44", "").replace("_dip_64", "").replace("_dip_48", "")
                
                if clean_name in file_base or file_base in clean_name:
                    print(f"âœ… Found file scan match: {file_base} -> {image_file.name}")
                    return str(image_file)
        
        print(f"âŒ No image found for: {component_name}")
        return None
    
    def load_chip_image(self, component_name: str, target_width: int = 200, target_height: int = 150) -> QPixmap:
        """Load and scale a chip image"""
        # Check cache first
        cache_key = f"{component_name}_{target_width}_{target_height}"
        if cache_key in self.image_cache:
            return self.image_cache[cache_key]
        
        # Find the image file
        image_path = self.find_chip_image(component_name)
        if not image_path:
            return QPixmap()  # Return null pixmap
        
        try:
            # Load the original image
            original_pixmap = QPixmap(image_path)
            if original_pixmap.isNull():
                print(f"âš ï¸ Failed to load pixmap from: {image_path}")
                return QPixmap()
            
            print(f"ğŸ“ Original size: {original_pixmap.width()}x{original_pixmap.height()}")
            
            # Scale with high quality
            scaled_pixmap = original_pixmap.scaled(
                target_width, target_height,
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            
            print(f"ğŸ“ Scaled to: {scaled_pixmap.width()}x{scaled_pixmap.height()}")
            
            # Cache the result
            self.image_cache[cache_key] = scaled_pixmap
            
            return scaled_pixmap
            
        except Exception as e:
            print(f"âš ï¸ Error loading image {image_path}: {e}")
            return QPixmap()
    
    def get_available_chips(self):
        """Get list of available chip images"""
        if not self.images_dir.exists():
            return []
        
        chips = []
        for image_file in self.images_dir.glob("*.png"):
            chips.append(image_file.stem)
        
        return sorted(chips)

# Global instance
chip_image_loader = ChipImageLoader()
'''
    
    # Write the loader module
    with open('chip_image_loader.py', 'w', encoding='utf-8') as f:
        f.write(loader_code)
    
    print("âœ… Created enhanced chip image loader: chip_image_loader.py")
    return True

def update_canvas_image_loading():
    """Update canvas.py to use the enhanced image loader"""
    canvas_file = "ui/canvas.py"
    
    if not os.path.exists(canvas_file):
        # Try alternative location
        canvas_file = "canvas.py"
        if not os.path.exists(canvas_file):
            print("âŒ Could not find canvas.py file")
            return False
    
    # Create backup
    backup_path = backup_file(canvas_file)
    
    # Read current file
    with open(canvas_file, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Add import for the enhanced loader at the top
    import_addition = '''
# Enhanced chip image loading
try:
    from chip_image_loader import chip_image_loader
    ENHANCED_IMAGE_LOADER = True
    print("âœ… Enhanced chip image loader available")
except ImportError:
    ENHANCED_IMAGE_LOADER = False
    print("âš ï¸ Enhanced chip image loader not available")
'''
    
    # Find a good place to insert the import (after existing imports)
    insert_pos = content.find('from PyQt6.QtGui import *')
    if insert_pos != -1:
        insert_pos = content.find('\n', insert_pos) + 1
    else:
        insert_pos = content.find('class EnhancedPCBCanvas')
        if insert_pos == -1:
            insert_pos = 100  # Fallback position
    
    # Insert the import
    new_content = content[:insert_pos] + import_addition + content[insert_pos:]
    
    # Update the _load_chip_image method to use enhanced loader
    if '_load_chip_image(self, component, name: str):' in new_content:
        # Find the method and replace it
        method_start = new_content.find('def _load_chip_image(self, component, name: str):')
        if method_start != -1:
            # Find the end of the method (next def or class)
            method_end = new_content.find('\n    def ', method_start + 1)
            if method_end == -1:
                method_end = new_content.find('\n\nclass ', method_start + 1)
            if method_end == -1:
                method_end = len(new_content)
            
            # Replace the method with enhanced version
            enhanced_method = '''    def _load_chip_image(self, component, name: str):
        """Load chip image using enhanced loader"""
        if not name:
            return
        
        # Use enhanced loader if available
        if ENHANCED_IMAGE_LOADER:
            try:
                pixmap = chip_image_loader.load_chip_image(name, 200, 150)
                if not pixmap.isNull():
                    # Store the pixmap
                    component.pinout_pixmap = pixmap
                    
                    # Update component size
                    if hasattr(component, 'setRect'):
                        component.setRect(0, 0, pixmap.width(), pixmap.height())
                    
                    print(f"ğŸ–¼ï¸ Loaded chip image for: {name}")
                    return
                else:
                    print(f"ğŸ“· No image found for: {name}")
            except Exception as e:
                print(f"âš ï¸ Error loading image for {name}: {e}")
        
        # Fallback to original method
        self._load_chip_image_fallback(component, name)
'''
            
            # Replace the method
            new_content = new_content[:method_start] + enhanced_method + new_content[method_end:]
            
            # Rename the original method as fallback
            new_content = new_content.replace('def _load_chip_image(self, component, name: str):', 
                                            'def _load_chip_image_fallback(self, component, name: str):')
    
    # Write the updated file
    with open(canvas_file, 'w', encoding='utf-8') as f:
        f.write(new_content)
    
    print(f"âœ… Updated {canvas_file} with enhanced image loading")
    return True

def test_image_loading():
    """Test the image loading system"""
    print("\nğŸ§ª TESTING IMAGE LOADING SYSTEM")
    print("=" * 50)
    
    try:
        from chip_image_loader import chip_image_loader
        
        # Test some common chips
        test_chips = [
            "6502", "VIC-II", "SID", "68000", "Z80",
            "Agnus", "Paula", "Denise", "ULA"
        ]
        
        print("Testing chip image lookup:")
        for chip in test_chips:
            image_path = chip_image_loader.find_chip_image(chip)
            if image_path:
                print(f"  âœ… {chip} -> {Path(image_path).name}")
            else:
                print(f"  âŒ {chip} -> No image found")
        
        # List available images
        available = chip_image_loader.get_available_chips()
        print(f"\nğŸ“ Available chip images: {len(available)}")
        for chip in available[:10]:
            print(f"  ğŸ“„ {chip}")
        if len(available) > 10:
            print(f"  ... and {len(available) - 10} more")
        
        return True
        
    except ImportError as e:
        print(f"âŒ Could not test image loader: {e}")
        return False

def main():
    """Main fix function"""
    print("ğŸ–¼ï¸ CHIP IMAGE DISPLAY FIX")
    print("=" * 50)
    print("Connecting retro_chip_generator images with canvas display")
    print()
    
    success_count = 0
    total_fixes = 4
    
    # Step 1: Scan existing images
    image_files = scan_existing_chip_images()
    if image_files:
        success_count += 1
        print("âœ… Found existing chip images")
    else:
        print("âš ï¸ No chip images found - run retro_chip_generator.py first")
    
    # Step 2: Create enhanced image loader
    if create_enhanced_image_loader():
        success_count += 1
    
    # Step 3: Update canvas image loading
    if update_canvas_image_loading():
        success_count += 1
    
    # Step 4: Test the system
    if test_image_loading():
        success_count += 1
    
    print()
    print("=" * 50)
    print(f"FIX RESULTS: {success_count}/{total_fixes} successful")
    
    if success_count >= 3:  # Allow for missing images
        print("âœ… Chip image display system updated!")
        print("ğŸ‰ Your retro chip images should now display in the canvas")
        print()
        print("What was done:")
        print("1. âœ… Scanned for existing chip images")
        print("2. âœ… Created enhanced image loader with smart mapping")
        print("3. âœ… Updated canvas to use enhanced loader")
        print("4. âœ… Tested the image loading system")
        print()
        if not image_files:
            print("ğŸ“ NEXT STEPS:")
            print("1. Generate chip images: python retro_chip_generator.py")
            print("2. Test your application: python main_app.py")
            print("3. Add components to see the realistic chip images!")
        else:
            print("ğŸš€ READY TO TEST:")
            print("1. Run your application: python main_app.py")
            print("2. Add components to the canvas")
            print("3. Enjoy your realistic retro chip images! ğŸ®")
    else:
        print("âš ï¸ Some fixes failed - check the errors above")
        print("Your original files are backed up")
    
    print()
    print("ğŸ›¡ï¸ Original files backed up with timestamps")

if __name__ == "__main__":
    main()
